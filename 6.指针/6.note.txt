1.内存中的每个位置由一个独一无二的地址标识
2.内存中的每个位置都包含一个值

不能简单地通过检查一个值的位来判断它的类型。为了判断值的类型（以及它的值），你必须观察程序中这个值的使用方式。

值的类型并非值本身所固有的一种特性，而是取决于它的使用方式。因此，为了得到正确的答案，对值进行正确的使用时非常重要的。

指针变量的值就是一个数字。

在你对指针进行间接访问之前，必须非常小心，确保它们已被初始化！

NULL指针的概念非常有用，因为它给了你一种方法，表示某个特定的指针目前并未指向任何东西。
尽管这个技巧在C程序中极为有用，但它违背了软件工程的原则。用一个单一的值表示两种不同的意思是件危险的事，因为将来很容易无法弄清哪个才是它真正的用意。

对一个NULL指针进行解引用操作是非法的。在对指针进行解引用操作之前，你首先必须确保它并非NULL指针（深有体会，很多bug的来源）

风格良好的程序会在指针解引用之前对它进行检查，这种初始化政策可以节省大量的调试时间。（非常重要的一句话）

指针变量可以作为左值，并不是因为它们是指针，而是因为它们是变量。

*100 = 25;//错误的写法，因为字面值100的类型是整型，而间接访问操作只能作用于指针类型表达式。
* (int *)100 = 25;//如果确实想把25存储于位置100，必须使用强制类型转换。
但是，你需要使用这种技巧的机会是很渺小的(不要总想搞大新闻)

int **c = &b;
*操作符具有从右向左的结合性，所以这个表达式相当于*(*c),我们必须从里向外逐层求值。

*(cp + 1); //注意指针加法运算的结果是个右值，因为它的存储位置并未清晰定义。如果没有间接访问操作，这个表达式将不是一个合法的左值。

如果两个指针所指向的不是同一个数组中的元素，那么它们之间相减的结果是未定义的。

标准未定义如果两个任意的指针进行比较会产生什么结果。

for(vp = &value[N];vp > &value[0];)
	*--vp = 0;//你可能会吐槽*--vp这样的表达式，但是，下边会向你展示一些东西。
以下两行是不好的代码
for(vp = &value[N-1];vp >= &value[0];vp--)
	*vp = 0;
发现没？在数组第1个元素被清除后，vp的值还将减去1，而接下来的一次比较运算时用于结束循环的。
问题就在：比较表达式 vp >= &value[0]的值是未定义的,因为vp移到了数组的边界之外。
标准允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针进行比较，但不允许与指向数组第1个元素之前的那个内存位置的指针进行比较。






