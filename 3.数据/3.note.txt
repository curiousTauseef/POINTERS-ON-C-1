字面值（literal）是字面值常量的缩写--这是一种实体，指定2了自身的值，并且不允许发生改变。
整数可以用不同的进制来表示，只要在数值面前以“某些字符”开头
	八进制 		以0开头
例：	0173	0177777	000060
  		
	十六进制	以0x开头
例：	0x7b	0xFFFF	0xabcdef00

在八进制字面值中，数字8和9是非法的。
在十六进制字面值中，可以使用字母ABCDEF或abcdef


字符常量就是一个用单引号包围起来的单个字符（或字符转义序列或三字母词）
如：	'M'		'\n'	'??('	'\377'
如果一个多字节字符常量的前面有一个L，那么它就是宽字符常量(wide character literal)
如：	L'X'	L'e^'	
当运行时环境支持一种宽字符集时，就有可能使用它们

value = value - 48;
value = value - \60;
value = value - '0';
'0'=='\60' 	转义字符可以表达出特定字符

浮点数字面值在缺省情况下都是double类型的，除非它的后面跟一个L或l表示它是一个long double类型的值，或者跟一个F或f表示它是一个float类型的值

C对指针使用的不加限制正是许多令人欲哭无泪和咬牙切齿的错误的根源

指针变量就是一个其值为另外一个（一些）内存地址的变量

字符串：一串以NUL字节结尾的零个或多个字符
之所以选择NUL作为字符串的终止符，是因为它不是一个可打印的字符

具有相同的值得不同字符串常量在内存中是分开存储的。因此，许多编译器都允许程序修改字符串常量
如果你需要修改字符串，请把它存储于数组中

你不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是这些字符本身

在声明整型变量时，如果声明中已经至少有了一个其他的说明符，关键字int可以省略
因此，下面两个声明的效果是相等的：
unsigned short int a;
unsigned short     a;

char a;//此时a是否是signed char,因编译器而异.

C数组另一个值得关注的地方是，编译器并不检查程序对数组下标的引用是否在数组的合法范围之内。这种不加检查的行为有好处也有坏处。好处是不需要浪费时间对有些已知是正确的数组下标进行检查。坏处是这样做将使无效的下标引用无法被检查出来。
一个良好的经验法则是：
	如果下标值是从那些已知是正确的值计算得来，那么就无需检查它的值。如果一个用作下标的值是
根据某种方法虫用户输入的数据产生而来的，那么在使用它之前必须进行检测，确保它们位于有效的范围之内

int* a;比int *a;看起来更加清晰的表明a被声明为类型为int*的指针。但是，
这并不是一个很好的技巧，原因如下：
	int* b,c,d;
这样声明会使得b为int*，但是c为int，d为int；
应该这样进行声明：
	int *b,*c,*d;
	
char *message = "Hello world!";
这种类型的声明所面临的一个危险是你容易误解它的意思。看上去初始值似乎是赋给表达式*message，事实上它是赋给message本身的。换句话说，这个声明相当于：
	char *message;
	message = "Hello world";
	
函数如果不显式地声明返回值的类型，它就默认返回整型
f(x) {return x+1};//隐式声明这种习惯不好

你应该使用typedef而不是#define来创建新的类型名，因为后者无法正确地出来指针类型。
例如：
	#define d_ptr_to_char char*
	d_ptr_to_char a,b;
正确声明了a，但是b却被声明为一个字符。在定义更为复杂的类型名字时，如函数指针或指向数组的指针，使用typedef更为合适.

int const a;等效于
const int a;

int const *pci;
是一个指向[整型常量]的指针，你可以修改指针的值，但你不能修改它所指向的值。相比之下：
int * const cpi;
则声明pci为一个指向[整型]的常量指针。此时指针是常量，它的值无法修改，但你可以修改它所指向的整型的值。

int const * const cpci;
在cpci这个例子里，无论是指针本身还是它所指向的值都是常量，不允许修改。

用#define创建名字常量比用const int的方法好，因为前者创建的能用于声明数组的长度，后者不能。

作用域（scope）：文件作用域，函数作用域，代码块作用域，原型作用域

代码块：位于一对花括号之间的所有语句

一大堆文件在一起编译时，如果相同的标识符出现在几个不同的源文件中时，标识符的链接属性
（linkage）决定如何处理在不同文件中出现的字符。
链接属性有三种：
1)external	外部	不论声明多少次，位于几个源文件都表示同一个实体
2)internal	内部
在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属于不同的实体
3)none		无		总是被当作单独的个体，该标识符的多个声明被当作独立不同的实体

问题：vs中在某个.h文件中定义了static int k=2；
但是在main.cpp中直接cout<<k能编译通过并且成功运行。

变量的存储类型(storage class)是指存储变量值得内存类型。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。
有三个地方可以用于存储变量：普通内存，运行时堆栈，硬件寄存器


