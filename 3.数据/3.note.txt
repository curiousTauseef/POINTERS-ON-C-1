字面值（literal）是字面值常量的缩写--这是一种实体，指定2了自身的值，并且不允许发生改变。
整数可以用不同的进制来表示，只要在数值面前以“某些字符”开头
	八进制 		以0开头
例：	0173	0177777	000060
  		
	十六进制	以0x开头
例：	0x7b	0xFFFF	0xabcdef00

在八进制字面值中，数字8和9是非法的。
在十六进制字面值中，可以使用字母ABCDEF或abcdef


字符常量就是一个用单引号包围起来的单个字符（或字符转义序列或三字母词）
如：	'M'		'\n'	'??('	'\377'
如果一个多字节字符常量的前面有一个L，那么它就是宽字符常量(wide character literal)
如：	L'X'	L'e^'	
当运行时环境支持一种宽字符集时，就有可能使用它们

value = value - 48;
value = value - \60;
value = value - '0';
'0'=='\60' 	转义字符可以表达出特定字符

浮点数字面值在缺省情况下都是double类型的，除非它的后面跟一个L或l表示它是一个long double类型的值，或者跟一个F或f表示它是一个float类型的值

C对指针使用的不加限制正是许多令人欲哭无泪和咬牙切齿的错误的根源

指针变量就是一个其值为另外一个（一些）内存地址的变量】

字符串：一串以NUL字节结尾的零个或多个字符
之所以选择NUL作为字符串的终止符，是因为它不是一个可打印的字符

具有相同的值得不同字符串常量在内存中是分开存储的。因此，许多编译器都允许程序修改字符串常量
如果你需要修改字符串，请把它存储于数组中

你不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是这些字符本身

在声明整型变量时，如果声明中已经至少有了一个其他的说明符，关键字int可以省略
因此，下面两个声明的效果是相等的：
unsigned short int a;
unsigned short     a;

char a;//此时a是否是signed char,因编译器而异.

C数组另一个值得关注的地方是，编译器并不检查程序对数组下标的引用是否在数组的合法范围之内。这种不加检查的行为有好处也有坏处。好处是不需要浪费时间对有些已知是正确的数组下标进行检查。坏处是这样做将使无效的下标引用无法被检查出来。
一个良好的经验法则是：
	如果下标值是从那些已知是正确的值计算得来，那么就无需检查它的值。如果一个用作下标的值是
根据某种方法虫用户输入的数据产生而来的，那么在使用它之前必须进行检测，确保它们位于有效的范围之内

int* a;比int *a;看起来更加清晰的表明a被声明为类型为int*的指针。但是，
这并不是一个很好的技巧，原因如下：
	int* b,c,d;
这样声明会使得b为int*，但是c为int，d为int；
应该这样进行声明：
	int *b,*c,*d;
	
char *message = "Hello world!";
这种类型的声明所面临的一个危险是你容易误解它的意思。看上去初始值似乎是赋给表达式*message，事实上它是赋给message本身的。换句话说，这个声明相当于：
	char *message;
	message = "Hello world";
	
函数如果不显式地声明返回值的类型，它就默认返回整型
f(x) {return x+1};//隐式声明这种习惯不好

你应该使用typedef而不是#define来创建新的类型名，因为后者无法正确地出来指针类型。
例如：
	#define d_ptr_to_char char*
	d_ptr_to_char a,b;
正确声明了a，但是b却被声明为一个字符。在定义更为复杂的类型名字时，如函数指针或指向数组的指针，使用typedef更为合适.